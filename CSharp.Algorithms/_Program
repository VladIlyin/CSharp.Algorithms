//using Algorithms.Model;
//using AlgoRythms.Shared.TestData;
//using CSharp.Algorithms.Shared;
//using System.Text;
//using Xunit;

////var ll = PopulateLinkedList(new int[] { 1, 2, 3, 4, 5 });

////ll.Print();

////LinkedList.ReverseList(ll).Print();



////var combsList = Combinatorics.Combine(4, 2);

////foreach (var combs in combsList)
////{
////    foreach (var comb in combs)
////    {
////        Console.Write(comb);
////    }

////    Console.WriteLine(Environment.NewLine);
////}



////var permsList = Combinatorics.Permute(new int[] { 1, 2, 3 });

////foreach (var perms in permsList)
////{
////    foreach (var perm in perms)
////    {
////        Console.Write(perm);
////    }

////    Console.WriteLine(Environment.NewLine);
////}



////var letterCasePerms = Combinatorics.LetterCasePermutation('a1bc2d');
////foreach (var perm in letterCasePerms)
////{
////    Console.WriteLine(perm);
////}



////Console.WriteLine(DynamicProgramming.ClimbStairs(2));
////Console.WriteLine(DynamicProgramming.ClimbStairs(3));
////Console.WriteLine(DynamicProgramming.ClimbStairs(4));
////Console.WriteLine(DynamicProgramming.ClimbStairs(5));
////Console.WriteLine(DynamicProgramming.ClimbStairs(6));
////Console.WriteLine(DynamicProgramming.ClimbStairs(7));
////Console.WriteLine(DynamicProgramming.ClimbStairs(45));
////Console.WriteLine(DynamicProgramming.ClimbStairs(50));


////Console.WriteLine(DynamicProgramming.Rob(new int[] { 1, 100, 1, 1, 1000, 1, 2 }));
////Console.WriteLine(DynamicProgramming.Rob(new int[] { 1, 100, 101, 2 }));


////var triangle = new int[][]
////{
////    new int[] { 2 },
////    new int[] { 3, 4 },
////    new int[] { 6, 5, 7 },
////    new int[] { 4, 1, 8, 3 }
////};

////Console.WriteLine(DynamicProgramming.MinimumTotal(triangle));



////Console.WriteLine(BitManipulation.IsPowerOfTwo(6));             // false
////Console.WriteLine(BitManipulation.IsPowerOfTwo(5));             // false
////Console.WriteLine(BitManipulation.IsPowerOfTwo(-2147483648));   // false
////Console.WriteLine(BitManipulation.IsPowerOfTwo(8));             // true
////Console.WriteLine(BitManipulation.IsPowerOfTwo(2));             // true




////Console.WriteLine(BitManipulation.HammingWeight(5)); // 0101 -> 2
////Console.WriteLine(BitManipulation.HammingWeight(7)); // 0111 -> 3



////Console.WriteLine(BitManipulation.ReverseBits(10));
////Console.WriteLine(BitManipulation.ReverseBits(43261596));


////Console.WriteLine(
////    BitManipulation.SingleNumber(new int[] { 2, 2, 7, 7, 1, 5, 5 })
////    ); // 1


////Console.WriteLine(Arrays.MaxSubArray(new int[] { -2, 1, -3 }));
////Console.WriteLine(Arrays.MaxSubArray(new int[] { -2, -5, -3 }));
////Console.WriteLine(Arrays.MaxSubArray(new int[] { 1, 1, 1, 1, 500, 1, 1 }));
////Console.WriteLine(Arrays.MaxSubArray(new int[] { -10, -451, -21, -12, -9, -8, -19 }));



////ConsoleHelper.Print(Arrays.TwoSum(new int[] { 2, 3, 1, 4 }, 7)); // 1 3
////ConsoleHelper.Print(Arrays.TwoSum(new int[] { 2, 7, 11, 15 }, 9)); // 0 1
////ConsoleHelper.Print(Arrays.TwoSum(new int[] { 3, 5, 6, 6, 1 }, 6)); // 1 4



////var arrMerged = new int[] { 10, 19, 25, 0, 0, 0, 0 };
////Arrays.Merge(arrMerged, 3, new int[] { 1, 5, 11, 29 }, 4);
////ConsoleHelper.Print(arrMerged);


////Assert.Equal(4, Arrays.MaxProfit(new int[] { 1, 2, 3, 4, 5 }));
////Assert.Equal(3, Arrays.MaxProfit(new int[] { 7, 4, 3, 2, 5 }));
////Assert.Equal(5, Arrays.MaxProfit(new int[] { 7, 1, 5, 3, 6, 4 }));
////Assert.Equal(11, Arrays.MaxProfit(new int[] { 1, 3, 4, 7, 4, 3, 2, 5, 6, 9, 10, 12, 1 }));
////Assert.Equal(0, Arrays.MaxProfit(new int[] { 10, 8, 7, 6, 2 }));


////var reshapedMatrix = Arrays.MatrixReshape(new int[][] { new int[] { 1, 2, 3, 4, 5 }, new int[] { 6, 7, 8, 9, 10 } }, 5, 2);
////ConsoleHelper.PrintMatrix(reshapedMatrix);


////var pascalTriangle = Arrays.Generate(5);



////var board = new char[][] {
////    new char [] {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
////    new char [] {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
////    new char [] {'.', '9', '.', '.', '.', '.', '.', '6', '.'},
////    new char [] {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
////    new char [] {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
////    new char [] {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
////    new char [] {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
////    new char [] {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
////    new char [] {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
////};

////var board2 = new char[][] {
////    new char [] {'.','.','.','.','5','.','.','1','.'},
////    new char [] {'.','4','.','3','.','.','.','.','.'},
////    new char [] {'.','.','.','.','.','3','.','.','1'},
////    new char [] {'8','.','.','.','.','.','.','2','.'},
////    new char [] {'.','.','2','.','7','.','.','.','.'},
////    new char [] {'.','1','5','.','.','.','.','.','.'},
////    new char [] {'.','.','.','.','.','2','.','.','.'},
////    new char [] {'.','2','.','9','.','.','.','.','.'},
////    new char [] {'.','.','4','.','.','.','.','.','.' }
////};

////Console.WriteLine(Arrays.IsValidSudoku(board2));


////Console.WriteLine(StringProblem.FirstUniqChar("loveleetcode"));

////Assert.Equal(2, StringProblem.FirstUniqChar("loveleetcode"));
////Assert.Equal(-1, StringProblem.FirstUniqChar("aaabbb"));
////Assert.Equal(6, StringProblem.FirstUniqChar("aaabbbc"));


////Console.WriteLine(StringProblem.CanConstruct("watchout", "coutwattch"));


////var head1 = new ListNode();
////Assert.False(LinkedList.HasCycle(head1));

////var head2 = new ListNode(1, new ListNode(2));
////Assert.False(LinkedList.HasCycle(head2));

////var head3 = new ListNode();
////head3.Insert(1, head3);
////Assert.True(LinkedList.HasCycle(head3));

////var head4 = new ListNode();
////head4.Insert(1);
////head4.Insert(2);
////head4.Insert(3, head4);
////Assert.True(LinkedList.HasCycle(head4));

////var head5 = new ListNode();
////head5.Insert(1);
////head5.Insert(2);
////head5.Insert(3);
////head5.Insert(4);
////head5.Insert(5);
////Assert.False(LinkedList.HasCycle(head5));


////var queue = StackQueue.CreateQueue();
////for (int i = 0; i < 100_000; i++)
////{
////    queue.Push(i);
////}
////Console.WriteLine(queue.Pop()); // 0
////Console.WriteLine(queue.Pop()); // 1
////Console.WriteLine(queue.Pop()); // 2


////var root = new TreeNode(10);
////root.left = new TreeNode(6);
////root.right = new TreeNode(17);
////root.left.left = new TreeNode(1);
////root.left.right = new TreeNode(8);
////root.right.left = new TreeNode(12);
////root.right.right = new TreeNode(21);

////ConsoleHelper.Print(TreeTraverse.PreOrderTraversal(root));
////ConsoleHelper.Print(TreeTraverse.InOrderTraversal(root));
////ConsoleHelper.Print(TreeTraverse.PostOrderTraversal(root));
////ConsoleHelper.Print(TreeTraverse.LevelOrderTraversal(root));

////var root = new TreeNode(3);
////root.left = new TreeNode(9);
////root.right = new TreeNode(20);
////root.right.left = new TreeNode(15);
////root.right.right = new TreeNode(7);

////foreach (var item in new TreeTraverse().LevelOrderTraversalList(root))
////{
////    ConsoleHelper.Print(item);
////}




////var root = new TreeNode(1);
////root.left = new TreeNode(2);
////root.right = new TreeNode(3);
////root.left.left = new TreeNode(4);
////root.left.right = new TreeNode(5);
////root.right.left = new TreeNode(6);
////root.right.right = new TreeNode(7);

////root.PrintLevelOrder();
////TreeProblem.InvertTree(root);
////root.PrintLevelOrder();




////var root = new TreeNode(10);
////root.right = new TreeNode(100);

////BinarySearchTreeProblem.InsertIntoBST(root, 50);
////root.PrintLevelOrder();




////var root = new TreeNode(2);
////root.left = new TreeNode(0);
////root.right = new TreeNode(3);
////root.left.left = new TreeNode(-4);
////root.left.right = new TreeNode(1);

////Console.WriteLine(TreeProblem.FindTarget(root, -1));


////var root = new TreeNode(1);
////root.right = new TreeNode(3);

////BinarySearchTreeProblem
////    .LowestCommonAncestor(root, root.left, root)?
////    .PrintNode(); // 3


////HashSet<long> set = new();
////long hash;
////byte[] hash_arr;
////BigInteger big_int;

////for (int i = 0; i < 5_000_000; i++)
////{
////    hash_arr = SHA256.HashData(Encoding.UTF8.GetBytes(GenerateTestData.GetRandomString(100)));
////    big_int = new BigInteger(hash_arr);
////    hash = Math.Abs((long)(big_int % Int64.MaxValue));

////    if (set.Contains(hash))
////    {
////        Console.WriteLine(hash);
////    }
////    else
////    {
////        set.Add(hash);
////    }
////}


//// TestBloomFilter();

//int expElements = 1_000_000;

//var m = BloomFilter.FilterMemory.BestM(expElements, 0.00001);   // 23_962_646   - optimal filter size in bits 
//var k = BloomFilter.FilterMemory.BestK(expElements, m);         // 17           - optimal amount of hash functions
//var p = BloomFilter.FilterMemory.BestP(k, m, expElements);      // 0.00001      - false positive probability

//BloomFilter.HashAlgorithms.Murmur2 murmur2 = new();
//var murmur_hash = murmur2.ComputeHash(Encoding.UTF8.GetBytes("ABCDEFGH"), 23_962_646, 17);
//var murmur_hash2 = murmur2.ComputeHash(Encoding.UTF8.GetBytes("ABCDEFGH"), 100, 1);

//BloomFilter.HashAlgorithms.HashCryptoSHA256 sha256 = new();
//var sha256_hash = sha256.ComputeHash(Encoding.UTF8.GetBytes("ABCDEFGH"), 10, 1);

//using (var bloomFilter = BloomFilter.FilterBuilder.Build(expElements, p))
//{
//    RandomString rs = new();

//    byte[] bytes;
//    List<int[]> hashes = new();

//    foreach (var str in rs.GetUniqueRandomStrings(10, expElements))
//    {
//        bytes = Encoding.UTF8.GetBytes(str);
//        bloomFilter.Add(bytes);
//        hashes.Add(bloomFilter.ComputeHash(bytes));
//    }

//    byte[] not_in_filter;

//    for (int i = 0; i < 100_000; i++)
//    {
//        not_in_filter = Encoding.UTF8.GetBytes(rs.GetUniqueRandomString(10));
//        try
//        {
//            Assert.True(bloomFilter.Contains(not_in_filter));

//            // false positive
//            Console.WriteLine(Encoding.UTF8.GetString(not_in_filter, 0, not_in_filter.Length));
//            var hashes_not_in_filter = bloomFilter.ComputeHash(not_in_filter);
//            foreach (var hash in hashes_not_in_filter)
//            {
//                Assert.True(hashes.Any(x => x.Contains(hash)));
//            }
//        }
//        catch
//        {
//        }
//    }
//}


//void TestBloomFilter()
//{
//    var bloomFilter = new Algorithms.Main.BloomFilter.BloomFilter();
//    uint count = 0;

//    HashSet<string> hs = new HashSet<string>();

//    foreach (var str in GenerateTestData.GetRandomStrings(10, 1_000_000))
//    {
//        if (!hs.Contains(str)) hs.Add(str);
        
//        bloomFilter.Set(str);
//        Assert.True(bloomFilter.Contains(str));
//        Assert.False(bloomFilter.Contains(GenerateTestData.GetRandomString(5)));
//        Assert.True(hs.Contains(str));
//    }
//}


//ListNode PopulateLinkedList(int[] arr)
//{
//    if (arr is null || arr.Length == 0)
//    {
//        return new ListNode();
//    }

//    var head = new ListNode(arr[0]);

//    for (int i = 1; i < arr.Length; i++)
//    {
//        Insert(head, arr[i]);
//    }

//    void Insert(ListNode node, int val)
//    {
//        var temp = node;

//        while (temp.next != null)
//        {
//            temp = temp.next;
//        }

//        temp.next = new ListNode(val);
//    }

//    return head;
//}


